import { spawn } from "child_process";
import { resolve, dirname, relative } from "path";
import { fileURLToPath } from "url";
import { writeFileSync } from "fs";
import pc from "picocolors";
import { loadConfig } from "../../config/loader.js";
import { discoverShowcaseFiles, type DiscoveredShowcase } from "../../utils/discovery.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface BuildOptions {
  config?: string;
  outDir?: string;
}

/**
 * Generate a TypeScript file with static imports for all showcase files
 * This allows Next.js/webpack to properly bundle the showcase files
 */
function generateShowcaseImportsFile(files: DiscoveredShowcase[], cwd: string): string {
  const appDir = resolve(__dirname, "../../../app");

  // Generate import statements with unique identifiers
  const imports = files.map((file, index) => {
    const relativePath = relative(appDir, file.absolutePath);
    return `import * as showcase_${index} from "${relativePath.startsWith('.') ? relativePath : `./${relativePath}`}";`;
  }).join('\n');

  // Generate the showcases array export
  const showcaseExports = files.map((_, index) => `showcase_${index}`).join(',\n  ');

  return `// AUTO-GENERATED FILE - DO NOT EDIT
// This file is automatically generated by the nextjs-showcase CLI
// It provides static imports for all showcase files to work around Next.js dynamic import limitations
// Note: This file must be imported from server components only to avoid bundling issues

${imports}

export const showcaseModules = [
  ${showcaseExports}
];

export const showcasePaths = [
${files.map((file, index) => `  { index: ${index}, path: "${file.relativePath}" }`).join(',\n')}
];
`;
}

export async function buildCommand(options: BuildOptions = {}) {
  try {
    // Load config
    const cwd = process.cwd();
    const config = await loadConfig(cwd);

    // Override output directory if provided
    const outDir = options.outDir || config.outDir;

    console.log(pc.cyan("Building Next.js Component Showcase...\n"));

    // Discover showcase files
    const files = await discoverShowcaseFiles(config, cwd);
    console.log(pc.dim(`  Found ${files.length} showcase file(s)`));
    console.log("");

    // Generate a manifest file that Next.js can read
    const manifestPath = resolve(__dirname, "../../../.showcase-manifest.json");
    const manifest = {
      config,
      files: files.map(f => ({
        path: f.absolutePath,
        relativePath: f.relativePath,
      })),
      cwd,
    };
    writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), "utf-8");

    // Generate a static imports file that Next.js can bundle
    // This solves the "Cannot find module as expression is too dynamic" error
    const importsFilePath = resolve(__dirname, "../../../app/.generated-showcases.ts");
    const importsFileContent = generateShowcaseImportsFile(files, cwd);
    writeFileSync(importsFilePath, importsFileContent, "utf-8");

    // Get the path to the Next.js app directory
    const appRoot = resolve(__dirname, "../../../");

    // Set environment variables
    const env = {
      ...process.env,
      SHOWCASE_CWD: cwd,
      SHOWCASE_MANIFEST_PATH: manifestPath,
    };

    // Build Next.js app
    console.log(pc.cyan("  Building Next.js app...\n"));

    const buildProcess = spawn("next", ["build"], {
      cwd: appRoot,
      stdio: "inherit",
      env,
      shell: true,
    });

    buildProcess.on("error", (error) => {
      console.error(pc.red("✗ Failed to build Next.js app:"));
      console.error(error);
      process.exit(1);
    });

    buildProcess.on("exit", (code) => {
      if (code === 0) {
        console.log("");
        console.log(pc.green("✓ Build completed successfully!"));
        console.log("");
        console.log(pc.dim(`  Output directory: ${outDir}`));
        console.log("");
      } else {
        console.error(pc.red(`✗ Build failed with code ${code}`));
        process.exit(code || 1);
      }
    });
  } catch (error) {
    console.error(pc.red("✗ Failed to build:"));
    console.error(error);
    process.exit(1);
  }
}
